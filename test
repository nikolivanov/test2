{
  title: 'Freshservice',

  methods: {
    make_schema_builder_fields_sticky: lambda do |schema|
      schema.map do |field|
        if field['properties'].present?
          field['properties'] = call('make_schema_builder_fields_sticky',
                                     field['properties'])
        end
        field['sticky'] = true

        field
      end
    end,
    format_schema: lambda do |input|
      input&.map do |field|
        if (props = field[:properties])
          field[:properties] = call('format_schema', props)
        elsif (props = field['properties'])
          field['properties'] = call('format_schema', props)
        end
        if (name = field[:name])
          field[:label] = field[:label].presence || name.labelize
          field[:name] = name
                        .gsub(/\W/) { |spl_chr| "__#{spl_chr.encode_hex}__" }
        elsif (name = field['name'])
          field['label'] = field['label'].presence || name.labelize
          field['name'] = name
                         .gsub(/\W/) { |spl_chr| "__#{spl_chr.encode_hex}__" }
        end

        field
      end
    end,
    format_payload: lambda do |payload|
      if payload.is_a?(Array)
        payload.map do |array_value|
          call('format_payload', array_value)
        end
      elsif payload.is_a?(Hash)
        payload.each_with_object({}) do |(key, value), hash|
          key = key.gsub(/__\w+__/) do |string|
            string.gsub(/__/, '').decode_hex.as_utf8
          end
          value = call('format_payload', value) if value.is_a?(Array) || value.is_a?(Hash)
          hash[key] = value
        end
      end
    end,
    format_response: lambda do |response|
      response = response&.compact unless response.is_a?(String) || response
      if response.is_a?(Array)
        response.map do |array_value|
          call('format_response', array_value)
        end
      elsif response.is_a?(Hash)
        response.each_with_object({}) do |(key, value), hash|
          key = key.gsub(/\W/) { |spl_chr| "__#{spl_chr.encode_hex}__" }
          value = call('format_response', value) if value.is_a?(Array) || value.is_a?(Hash)
          hash[key] = value
        end
      else
        response
      end
    end,

    generate_item_attribute: lambda do |input|
      custom_fields = get("/catalog/items/#{input}.json").dig('catalog_item', 'custom_fields')

      type_map = {
        'text' => 'string',
        'paragraph' => 'string',
        'checkbox' => 'boolean',
        'number' => 'integer',
        'decimal' => 'number',
        'date' => 'date',
        'multi' => 'integer'
      }
      control_type_map = {
        'text' => 'text',
        'paragraph' => 'text-area',
        'checkbox' => 'checkbox',
        'number' => 'integer',
        'decimal' => 'number',
        'dropdown' => 'select',
        'multi' => 'multiselect',
        'date' => 'date_time'
      }
      type_conversion_map = {
        'string' => nil,
        'boolean' => 'boolean_conversion',
        'integer' => 'integer_conversion',
        'number' => 'float_conversion',
        'date' => 'date_conversion'
      }

      custom_fields.map do |custom_field|
        type = custom_field['field_type'].split(/_/)[1] || ''
        pick_list_values = if (choices = custom_field['choices'].presence)
                             if choices.is_a?(Array)
                               choices
                             elsif choices.is_a?(Hash)
                               choices.map do |key, value|
                                 [key.labelize, value]
                               end
                             end
                           end

        if type == 'multi' && (choices = custom_field['choices'].presence)
          pick_list_values = if choices.is_a?(Array)
                               choices.map { |item| [item.first, item.first] }
                             else
                               choices.map do |key, _value|
                                 [key.labelize, key]
                               end
                             end
        end

        {
          name: custom_field['name'],
          label: custom_field['label'],
          optional: !custom_field['required'],
          control_type: control_type_map[type],
          type: (internal_type = type_map[type]),
          sticky: true,
          delimiter: type == 'multi' ? ',' : nil,
          pick_list: pick_list_values,
          render_input: (conversion = type_conversion_map[internal_type]),
          parse_output: conversion

        }.compact
      end
    end,

    build_schema_from_metadata: lambda do |input|
      operation = input['operation'] || ''
      type_map = {
        'text' => 'string',
        'paragraph' => 'string',
        'checkbox' => 'boolean',
        'number' => 'integer',
        'decimal' => 'number',
        'date' => 'date',
        'multi' => 'integer'
      }
      control_type_map = {
        'text' => 'text',
        'paragraph' => 'text-area',
        'checkbox' => 'checkbox',
        'number' => 'integer',
        'decimal' => 'number',
        'dropdown' => 'select',
        'multi' => 'multiselect',
        'date' => 'date_time'
      }
      type_conversion_map = {
        'string' => nil,
        'boolean' => 'boolean_conversion',
        'integer' => 'integer_conversion',
        'number' => 'float_conversion',
        'date' => 'date_conversion'
      }

      custom_field_optional = true
      dynamic_schema = input['dynamic_schema']
      custom_field_props = dynamic_schema.reject do |field|
        %w[default nested].include? field['type'].split(/_/)[0]
      end
      custom_field_props =
        custom_field_props
        .map do |custom_field|
          type = custom_field['type'].split(/_/)[1] || ''
          custom_field_optional = false if custom_field['required_for_agents']
          pick_list_values = if (choices = custom_field['choices'].presence)
                               if choices.is_a?(Array)
                                 choices.map do |array_value|
                                   [array_value.labelize, array_value]
                                 end
                               elsif choices.is_a?(Hash)
                                 choices.map do |key, value|
                                   [key.labelize, value]
                                 end
                               end
                             end

          if type == 'multi' && (choices = custom_field['choices'].presence)
            pick_list_values = choices.map do |key, _value|
              [key.labelize, key]
            end
          end

          {
            name: custom_field['name'],
            label: custom_field['label'],
            optional:
            operation == 'create' ? !custom_field['required_for_agents'] : true,
            control_type: control_type_map[type],
            type: (internal_type = type_map[type]),
            render_input: (conversion = type_conversion_map[internal_type]),
            parse_output: conversion,
            delimiter: type == 'multi' ? ',' : nil,
            pick_list: pick_list_values

          }.compact
        end

      (static_schema = input['static_schema'])
        .map do |static_field|
        internal_type = static_field[:type]
        field_name = static_field[:name]
        dynamic_field = dynamic_schema.where('name' => field_name)[0]

        if operation == 'create' && dynamic_field.present?
          static_field[:optional] =
            (static_field[:optional].present? ? static_field[:optional] : !dynamic_field['required_for_agents'])
        end

        static_field[:render_input] =
          (conversion = type_conversion_map[internal_type])
        static_field[:render_input] = conversion
      end
      custom_fields = static_schema.where(name: 'custom_fields')[0]
      if custom_field_props
        custom_fields[:ngIf] = 'true'
        custom_fields[:optional] =
          (operation == 'create' ? custom_field_optional : true)
        custom_fields[:sticky] = true
        custom_fields[:type] = 'object'
        custom_fields[:properties] = custom_field_props
      else
        custom_fields[:ngIf] = 'false'
      end

      static_schema
    end
  },

  connection: {
    fields: [
      {
        name: 'helpdesk',
        hint: 'Your helpdesk name as found in your FreshService URL',
        optional: false,
        control_type: 'subdomain',
        url: '.freshservice.com'
      },
      {
        name: 'is_api_key',
        label: 'Do you have API key?',
        hint: 'Connect using either API key or username and password',
        optional: false,
        control_type: 'checkbox',
        type: 'boolean'
      },
      {
        ngIf: 'input.is_api_key == "false"',
        name: 'username',
        optional: true
      },
      {
        ngIf: 'input.is_api_key == "false"',
        name: 'password',
        control_type: 'password',
        optional: true
      },
      {
        ngIf: 'input.is_api_key == "true"',
        name: 'api_key',
        label: 'API key',
        hint: 'Follow instructions <a ' \
        "href='https://api.freshservice.com/#authentication' " \
        "target='_blank'>here</a>, to get your API key.",
        control_type: 'password',
        optional: true
      }
    ],

    authorization: {
      type: 'basic_auth',

      apply: lambda do |connection|
        if connection['is_api_key'] == 'true'
          user(connection['api_key'])
        else
          user(connection['username'])
          password(connection['password'])
        end
      end
    },

    base_uri: lambda { |connection|
      "https://#{connection['helpdesk']}.freshservice.com/api/v2/"
    }
  },

  test: ->(_connection) { get('requester_fields') },

  object_definitions: {
    custom_action_input: {
      fields: lambda do |connection, config_fields|
        verb = config_fields['verb']
        input_schema = parse_json(config_fields.dig('input', 'schema') || '[]')
        data_props =
          input_schema.map do |field|
            if config_fields['request_type'] == 'multipart' &&
               field['binary_content'] == 'true'
              field['type'] = 'object'
              field['properties'] = [
                { name: 'file_content', optional: false },
                {
                  name: 'content_type',
                  default: 'text/plain',
                  sticky: true
                },
                { name: 'original_filename', sticky: true }
              ]
            end
            field
          end
        data_props = call('make_schema_builder_fields_sticky', data_props)
        input_data =
          if input_schema.present?
            if input_schema.dig(0, 'type') == 'array' &&
               input_schema.dig(0, 'details', 'fake_array')
              {
                name: 'data',
                type: 'array',
                of: 'object',
                properties: data_props.dig(0, 'properties')
              }
            else
              { name: 'data', type: 'object', properties: data_props }
            end
          end

        [
          {
            name: 'path',
            hint: "Base URI is <b>https://#{connection['helpdesk']}" \
            '.freshservice.com/api/v2/</b> - path will be appended to this ' \
            'URI. Use absolute URI to override this base URI.',
            optional: false
          },
          if %w[post put patch].include?(verb)
            {
              name: 'request_type',
              default: 'json',
              sticky: true,
              extends_schema: true,
              control_type: 'select',
              pick_list: [
                ['JSON request body', 'json'],
                ['URL encoded form', 'url_encoded_form'],
                ['Mutipart form', 'multipart'],
                ['Raw request body', 'raw']
              ]
            }
          end,
          {
            name: 'response_type',
            default: 'json',
            sticky: false,
            extends_schema: true,
            control_type: 'select',
            pick_list: [['JSON response', 'json'], ['Raw response', 'raw']]
          },
          if %w[get options delete].include?(verb)
            {
              name: 'input',
              label: 'Request URL parameters',
              sticky: true,
              add_field_label: 'Add URL parameter',
              control_type: 'form-schema-builder',
              type: 'object',
              properties: [
                {
                  name: 'schema',
                  sticky: input_schema.blank?,
                  extends_schema: true
                },
                input_data
              ].compact
            }
          else
            {
              name: 'input',
              label: 'Request body parameters',
              sticky: true,
              type: 'object',
              properties:
                if config_fields['request_type'] == 'raw'
                  [{
                    name: 'data',
                    sticky: true,
                    control_type: 'text-area',
                    type: 'string'
                  }]
                else
                  [
                    {
                      name: 'schema',
                      sticky: input_schema.blank?,
                      extends_schema: true,
                      schema_neutral: true,
                      control_type: 'schema-designer',
                      sample_data_type: 'json_input',
                      custom_properties:
                        if config_fields['request_type'] == 'multipart'
                          [{
                            name: 'binary_content',
                            label: 'File attachment',
                            default: false,
                            optional: true,
                            sticky: true,
                            render_input: 'boolean_conversion',
                            parse_output: 'boolean_conversion',
                            control_type: 'checkbox',
                            type: 'boolean'
                          }]
                        end
                    },
                    input_data
                  ].compact
                end
            }
          end,
          {
            name: 'request_headers',
            sticky: false,
            extends_schema: true,
            control_type: 'key_value',
            empty_list_title: 'Does this HTTP request require headers?',
            empty_list_text: 'Refer to the API documentation and add ' \
            'required headers to this HTTP request',
            item_label: 'Header',
            type: 'array',
            of: 'object',
            properties: [{ name: 'key' }, { name: 'value' }]
          },
          unless config_fields['response_type'] == 'raw'
            {
              name: 'output',
              label: 'Response body',
              sticky: true,
              extends_schema: true,
              schema_neutral: true,
              control_type: 'schema-designer',
              sample_data_type: 'json_input'
            }
          end,
          {
            name: 'response_headers',
            sticky: false,
            extends_schema: true,
            schema_neutral: true,
            control_type: 'schema-designer',
            sample_data_type: 'json_input'
          }
        ].compact
      end
    },

    custom_action_output: {
      fields: lambda do |_connection, config_fields|
        response_body = { name: 'body' }

        [
          if config_fields['response_type'] == 'raw'
            response_body
          elsif (output = config_fields['output'])
            output_schema = call('format_schema', parse_json(output))
            if output_schema.dig(0, 'type') == 'array' &&
               output_schema.dig(0, 'details', 'fake_array')
              response_body[:type] = 'array'
              response_body[:properties] = output_schema.dig(0, 'properties')
            else
              response_body[:type] = 'object'
              response_body[:properties] = output_schema
            end

            response_body
          end,
          if (headers = config_fields['response_headers'])
            header_props = parse_json(headers)&.map do |field|
              if field[:name].present?
                field[:name] = field[:name].gsub(/\W/, '_').downcase
              elsif field['name'].present?
                field['name'] = field['name'].gsub(/\W/, '_').downcase
              end
              field
            end

            { name: 'headers', type: 'object', properties: header_props }
          end
        ].compact
      end
    },

    requester_create: {
      fields: lambda do |_connection, _config_fields|
        static_schema = [
          {
            name: 'id',
            hint: 'User ID of the requester.',
            control_type: 'number',
            type: 'integer',
            optional: false
          },
          { name: 'first_name', hint: 'First name of the requester.' },
          { name: 'last_name', hint: 'Last name of the requester.' },
          { name: 'job_title', hint: 'Job title of the requester.' },
          {
            name: 'primary_email',
            hint: 'Primary email address of the requester.',
            control_type: 'email',
            optional: false
          },
          {
            name: 'secondary_emails',
            hint: 'Additional/secondary emails associated with the requester.',
            type: 'array',
            of: 'string'
          },
          {
            name: 'work_phone_number',
            hint: 'Work phone number of the requester.',
            control_type: 'number',
            type: 'integer',
            optional: false
          },
          {
            name: 'mobile_phone_number',
            hint: 'Mobile phone number of the requester.',
            control_type: 'number',
            type: 'integer',
            optional: false
          },
          {
            name: 'department_ids',
            hint: 'Unique IDs of the departments associated with the requester',
            type: 'array',
            of: 'integer'
          },
          {
            name: 'reporting_manager_id',
            hint: 'User ID of the requester’s reporting manager.',
            control_type: 'number',
            type: 'integer'
          },
          { name: 'address', hint: 'Address of the requester.' },
          {
            name: 'time_zone',
            hint: 'Time zone of the requester. Read more <a href="https://support.freshservice.com/support/solutions/' \
            'articles/232302-list-of-time-zones-supported-in-freshservice" target="_blank">here</a>.'
          },
          {
            name: 'language',
            hint: 'Language used by the requester. The default language ' \
            'is “en” (English). Read more here.'
          },
          {
            name: 'location_id',
            hint: 'Unique ID of the location associated with the requester.',
            control_type: 'number',
            type: 'integer'
          },
          {
            name: 'background_information',
            hint: 'Background information of the requester.'
          },
          {
            name: 'custom_fields',
            hint: 'Key-value pair containing the names and values of ' \
            'the (custom) requester fields.'
          }
        ]
        dynamic_schema = get('requester_fields')['requester_fields']

        call('build_schema_from_metadata',
             'dynamic_schema' => dynamic_schema,
             'static_schema' => static_schema,
             'operation' => 'create')
      end
    },

    requester_update: {
      fields: lambda do |_connection, _config_fields|
        static_schema = [
          {
            name: 'id',
            hint: 'User ID of the requester.',
            sticky: true,
            control_type: 'number',
            type: 'integer',
            optional: false
          },
          {
            name: 'first_name',
            hint: 'First name of the requester.',
            sticky: true,
            optional: true
          },
          {
            name: 'last_name',
            hint: 'Last name of the requester.',
            sticky: true
          },
          { name: 'job_title', hint: 'Job title of the requester.' },
          {
            name: 'primary_email',
            hint: 'Primary email address of the requester.',
            control_type: 'email'
          },
          {
            name: 'secondary_emails',
            hint: 'Additional/secondary emails associated with the requester.',
            type: 'array',
            of: 'string'
          },
          {
            name: 'work_phone_number',
            hint: 'Work phone number of the requester.',
            control_type: 'number',
            type: 'integer'
          },
          {
            name: 'mobile_phone_number',
            hint: 'Mobile phone number of the requester.',
            control_type: 'number',
            type: 'integer'
          },
          {
            name: 'department_ids',
            hint: 'Unique IDs of the departments associated with the requester',
            type: 'array',
            of: 'integer'
          },
          {
            name: 'reporting_manager_id',
            hint: 'User ID of the requester’s reporting manager.',
            control_type: 'number',
            type: 'integer'
          },
          { name: 'address', hint: 'Address of the requester.' },
          {
            name: 'time_zone',
            hint: 'Time zone of the requester. Read more here.'
          },
          {
            name: 'language',
            hint: 'Language used by the requester. The default language ' \
            'is “en” (English). Read more here.'
          },
          {
            name: 'location_id',
            hint: 'Unique ID of the location associated with the requester.',
            control_type: 'number',
            type: 'integer'
          },
          {
            name: 'background_information',
            hint: 'Background information of the requester.'
          },
          {
            name: 'custom_fields',
            hint: 'Key-value pair containing the names and values of ' \
            'the (custom) requester fields.'
          }
        ]
        dynamic_schema = get('requester_fields')['requester_fields']

        call('build_schema_from_metadata',
             'dynamic_schema' => dynamic_schema,
             'static_schema' => static_schema,
             'operation' => 'read')
      end
    },

    requester_read: {
      fields: lambda do |_connection, _config_fields|
        static_schema = [
          { name: 'id', type: 'integer' },
          { name: 'first_name' },
          { name: 'last_name' },
          { name: 'job_title' },
          { name: 'primary_email' },
          { name: 'secondary_emails',
            type: 'array',
            of: 'string' },
          { name: 'work_phone_number', type: 'integer' },
          { name: 'mobile_phone_number', type: 'integer' },
          { name: 'department_ids',
            type: 'array',
            of: 'integer' },
          { name: 'reporting_manager_id', type: 'integer' },
          { name: 'address' },
          { name: 'time_zone' },
          { name: 'language' },
          { name: 'location_id', type: 'integer' },
          { name: 'background_information' },
          { name: 'custom_fields' },
          { name: 'updated_at', type: 'date_time' }
        ]
        dynamic_schema = get('requester_fields')['requester_fields']

        call('build_schema_from_metadata',
             'dynamic_schema' => dynamic_schema,
             'static_schema' => static_schema,
             'operation' => 'read')
      end
    },

    ticket_create: {
      fields: lambda do |_connection, _config_fields|
        static_schema = [
          { name: 'requester',
            hint: 'Ticket requester',
            type: 'object',
            properties: [
              {
                name: 'requester_id',
                sticky: true,
                hint: 'User ID of the requester. For existing contacts, ' \
                "the requester_id can be passed instead of the requester's email.",
                type: 'integer',
                render_input: 'integer_conversion',
                parse_output: 'integer_conversion'
              },
              {
                name: 'email',
                sticky: true,
                hint: 'Email address of the requester. If no contact exists ' \
                'with this email address in Freshservice, it will be added as ' \
                'a new contact.',
                control_type: 'email'
              },
              {
                name: 'phone',
                sticky: true,
                hint: 'Phone number of the requester. If no contact exists with ' \
                'this phone number in Freshservice, it will be added as a new ' \
                'contact. <b>If the phone number is set and the email address is ' \
                'not, then the name attribute is mandatory.</b>',
                control_type: 'phone'
              },
              { name: 'name',
                sticky: true,
                hint: 'Name of the requester.' }
            ] },
          { name: 'subject',
            hint: 'Subject of the ticket.' },
          {
            name: 'type',
            hint: 'Helps categorize the ticket according to the different ' \
            'kinds of issues your support team deals with. [Support for only ' \
            'type ‘incident’ as of now]',
            default: 'Incident',
            control_type: 'select',
            pick_list: 'ticket_types',
            toggle_hint: 'Select from list',
            toggle_field: {
              name: 'type',
              label: 'Type',
              optional: true,
              hint: 'Helps categorize the ticket according to the different ' \
              'kinds of issues your support team deals with. [Support for ' \
              'only type ‘incident’ as of now]',
              toggle_hint: 'Use custom value',
              type: 'string'
            }
          },
          {
            name: 'status',
            hint: 'Status of the ticket.',
            control_type: 'select',
            type: 'integer',
            pick_list: 'statuses',
            toggle_hint: 'Select from list',
            toggle_field: {
              name: 'status',
              label: 'Status',
              hint: 'Status of the ticket. Valid values are <b>2 to 5</b> ' \
              '(Open - <b>2</b>, Pending - <b>3</b>, Resolved - <b>4</b>, Closed - <b>5</b>).',
              toggle_hint: 'Use custom value',
              control_type: 'integer',
              type: 'integer'
            }
          },
          {
            name: 'priority',
            hint: 'Priority of the ticket.',
            control_type: 'select',
            pick_list: 'priorities',
            type: 'integer',
            toggle_hint: 'Select from list',
            toggle_field: {
              name: 'priority',
              label: 'Priority',
              hint: 'Priority of the ticket. Valid values are <b>1 to 4</b> ' \
              '(Low - <b>1</b>, Medium - <b>2</b>, High - <b>3</b>, Urgent - <b>4</b>).',
              toggle_hint: 'Use custom value',
              control_type: 'number',
              type: 'integer'
            }
          },
          {
            name: 'cc_emails',
            hint: "Email addresses added in the 'cc' field of the incoming " \
            'ticket email.',
            type: 'array',
            of: 'string'
          },
          {
            name: 'department_id',
            type: 'integer',
            render_input: 'integer_conversion',
            parse_output: 'integer_conversion',
            hint: 'ID of the department to which this ticket belongs.'
          },
          {
            name: 'custom_fields',
            hint: 'Key value pairs containing the names and values of custom ' \
            "fields. <a href='https://support.freshservice.com" \
            "/support/solutions/articles/154126-customizing-ticket-fields' " \
            "target='_blank'>Learn more</a>."
          },
          { name: 'description', hint: 'HTML content of the ticket.' },
          {
            name: 'email_config_id',
            hint: 'ID of email config which is used for this ticket. ' \
            '(i.e., support@yourcompany.com/sales@yourcompany.com)',
            type: 'integer'
          },
          {
            name: 'group_id',
            hint: 'ID of the group to which the ticket has been assigned.',
            type: 'integer',
            render_input: 'integer_conversion',
            parse_output: 'integer_conversion'
          },
          { name: 'category',
            hint: 'Ticket Category',
            control_type: 'select',
            pick_list: 'ticket_categories',
            type: 'string',
            toggle_hint: 'Select from list',
            toggle_field: {
              name: 'category',
              label: 'Category',
              hint: 'Enter category',
              optional: true,
              toggle_hint: 'Use custom value',
              control_type: 'text',
              type: 'string'
            } },
          { name: 'sub_category',
            hint: 'Sub category.',
            control_type: 'select',
            pick_list: 'ticket_sub_categories',
            pick_list_params: { category: 'category' },
            type: 'string',
            toggle_hint: 'Select from list',
            toggle_field: {
              name: 'sub_category',
              label: 'Sub category',
              optional: true,
              hint: 'Enter sub category',
              toggle_hint: 'Use custom value',
              control_type: 'text',
              type: 'string'
            } },
          { name: 'item_category',
            hint: 'Ticket Item Category.',
            control_type: 'select',
            pick_list: 'ticket_item_categories',
            pick_list_params: { sub_category: 'sub_category', category: 'category' },
            type: 'string',
            toggle_hint: 'Select from list',
            toggle_field: {
              name: 'item_category',
              label: 'Item category',
              optional: true,
              hint: 'Enter item category',
              toggle_hint: 'Use custom value',
              control_type: 'text',
              type: 'string'
            } },
          {
            name: 'responder_id',
            hint: 'ID of the agent to whom the ticket has been assigned.',
            type: 'integer'
          },
          {
            name: 'source',
            hint: 'The channel through which the ticket was created.',
            default: 2,
            control_type: 'select',
            type: 'integer',
            pick_list: 'sources',
            toggle_hint: 'Select from list',
            toggle_field: {
              name: 'source',
              label: 'Source',
              optional: true,
              hint: 'The channel through which the ticket was created. ' \
              'Valid values are: <b>1 to 10</b> (Email - <b>1</b>, Portal - <b>2</b>, ' \
              'Phone - <b>3</b>, Chat - <b>4</b>, Feedback widget - <b>5</b>, Yammer - <b>6</b>, ' \
              'AWS Cloudwatch - <b>7</b>, Pagerduty - <b>8</b>, Walkup - <b>9</b>, Slack - <b>10</b>).',
              toggle_hint: 'Use custom value',
              control_type: 'number',
              type: 'integer'
            }
          },
          {
            name: 'tags',
            hint: 'Tags that have been associated with the ticket.',
            type: 'array',
            of: 'string'
          },
          {
            name: 'fr_due_by',
            label: 'Response within',
            hint: 'Timestamp that denotes when the first response is due.',
            type: 'timestamp'
          },
          {
            name: 'due_by',
            label: 'Resolve within',
            hint: 'Timestamp that denotes when the ticket is due to be ' \
            'resolved.',
            type: 'timestamp'
          },
          { name: 'urgency',
            hint: 'Ticket urgency.',
            type: 'integer',
            control_type: 'select',
            pick_list: 'urgencies',
            toggle_hint: 'Select from list',
            toggle_field: {
              name: 'urgency',
              label: 'Urgency',
              optional: true,
              hint: 'Valid values are: <b>1 to 3</b>. (Low - <b>1</b>, Medium - <b>2</b>, High - <b>3</b>)',
              toggle_hint: 'Use custom value',
              type: 'integer'
            } },
          { name: 'impact',
            hint: 'Ticket impact.',
            type: 'integer',
            control_type: 'select',
            pick_list: 'impacts',
            toggle_hint: 'Select from list',
            toggle_field: {
              name: 'impact',
              label: 'Impact',
              optional: true,
              hint: 'Valid values are: <b>1 to 3</b>. (Low - <b>1</b>, Medium - <b>2</b>, High - <b>3</b>)',
              toggle_hint: 'Use custom value',
              type: 'integer'
            } }
        ]
        dynamic_schema = get('ticket_fields')['ticket_fields']

        call('build_schema_from_metadata',
             'dynamic_schema' => dynamic_schema,
             'static_schema' => static_schema,
             'operation' => 'create')
      end
    },

    ticket_read: {
      fields: lambda do |_connection, _config_fields|
        static_schema = [
          { name: 'id', type: 'integer' },
          { name: 'department_id', type: 'integer' },
          { name: 'cc_emails',
            type: 'array',
            of: 'string' },
          { name: 'fwd_emails',
            label: 'Foward emails',
            type: 'array',
            of: 'string' },
          {
            name: 'reply_cc_emails',
            type: 'array',
            of: 'string'
          },
          { name: 'custom_fields', custom: true },
          { name: 'deleted', type: 'boolean' },
          { name: 'description' },
          { name: 'description_text' },
          { name: 'due_by', type: 'timestamp' },
          { name: 'email_config_id', type: 'integer' },
          { name: 'fr_due_by', type: 'timestamp', label: 'First response due by' },
          { name: 'fr_escalated', type: 'boolean', label: 'First response escalated' },
          { name: 'group_id', type: 'integer' },
          { name: 'is_escalated', type: 'boolean' },
          { name: 'priority', type: 'integer' },
          { name: 'category', type: 'integer' },
          { name: 'sub_category' },
          { name: 'item_category' },
          { name: 'requester_id', type: 'integer' },
          { name: 'responder_id', type: 'integer' },
          { name: 'source', type: 'integer' },
          { name: 'spam', type: 'boolean' },
          { name: 'subject' },
          { name: 'tags',
            type: 'array',
            of: 'string' },
          { name: 'to_emails',
            type: 'array',
            of: 'string' },
          { name: 'type' },
          { name: 'urgency', type: 'integer' },
          { name: 'impact', type: 'integer' },
          { name: 'created_at', type: 'timestamp' },
          { name: 'updated_at', type: 'timestamp' }
        ]
        dynamic_schema = get('ticket_fields')['ticket_fields']

        call('build_schema_from_metadata',
             'dynamic_schema' => dynamic_schema,
             'static_schema' => static_schema,
             'operation' => 'read')
      end
    },

    service_request_create: {
      fields: lambda do |_connection, config_fields|
        [
          { name: 'quantity',
            type: 'integer',
            sticky: true,
            render_input: 'integer_conversion',
            parse_output: 'integer_conversion' },
          { name: 'requested_for', sticky: true },
          { name: 'requester_email', control_type: 'email', sticky: true },
          {
            name: 'requested_item_value_attributes',
            type: 'object',
            properties: call('generate_item_attribute', config_fields['display_id'].presence)
          }
        ].compact
      end
    },

    service_request_read: {
      fields: lambda do |_connection, config_fields|
        [
          { name: 'id', type: 'number' },
          { name: 'requester_id', type: 'number' },
          { name: 'responder_id', type: 'number' },
          { name: 'status', type: 'integer' },
          { name: 'source', type: 'integer' },
          { name: 'spam', type: 'boolean' },
          { name: 'deleted', type: 'boolean' },
          { name: 'created_at', type: 'timestamp' },
          { name: 'updated_at', type: 'timestamp' },
          { name: 'subject' },
          { name: 'display_id', type: 'integer' },
          { name: 'owner_id', type: 'integer' },
          { name: 'group_id', type: 'integer' },
          { name: 'due_by', type: 'timestamp' },
          { name: 'frDueBy', label: 'First response due by', type: 'timestamp' },
          { name: 'isescalated', label: 'Is escalated', type: 'boolean' },
          { name: 'priority', type: 'integer' },
          { name: 'fr_escalated', label: 'First response escalated', type: 'boolean' },
          { name: 'ticket_type' },
          { name: 'urgency', type: 'integer' },
          { name: 'impact', type: 'integer' },
          { name: 'category' },
          { name: 'sub_category' },
          { name: 'item_category' },
          { name: 'requested_catalog_items',
            type: 'array',
            of: 'object',
            properties: [
              { name: 'id', type: 'number' },
              { name: 'service_request_id', type: 'number' },
              { name: 'item_id', type: 'number' },
              { name: 'is_parent', type: 'boolean' },
              { name: 'stage', type: 'integer' },
              { name: 'quantity', type: 'integer' },
              { name: 'created_at', type: 'timestamp' },
              { name: 'updated_at', type: 'timestamp' },
              { name: 'remarks' },
              { name: 'from_date', type: 'date' },
              { name: 'to_date', type: 'date' },
              { name: 'location_id', type: 'integer' },
              { name: 'item_type', type: 'integer' },
              {
                name: 'custom_field_values',
                type: 'object',
                properties: call('generate_item_attribute', config_fields['display_id'].presence)
              }
            ] }
        ].compact
      end
    },

    agent_read: {
      fields: lambda do |_connection, _config_fields|
        static_schema = [
          { name: 'id', type: 'integer' },
          { name: 'first_name' },
          { name: 'last_name' },
          { name: 'email', control_type: 'email', sticky: true },
          { name: 'language' },
          { name: 'job_title' },
          { name: 'work_phone_number', sticky: true },
          { name: 'mobile_phone_number', sticky: true },
          { name: 'address' },
          { name: 'location_id' },
          { name: 'time_zone' },
          { name: 'time_format' },
          { name: 'background_information' },
          { name: 'reporting_manager_id', type: 'integer' },
          { name: 'role_ids', label: 'Role IDs', type: 'array', of: 'integer' },
          { name: 'roles', type: 'array', of: 'object', properties: [
            { name: 'role_id', type: 'integer' },
            { name: 'assignment_scope' },
            { name: 'groups', type: 'array', of: 'integer' }
          ] },
          { name: 'department_ids', type: 'array', of: 'integer' },
          { name: 'scoreboard_level_id', type: 'integer' },
          { name: 'scoreboard_points' },
          { name: 'signature' },
          { name: 'occasional', type: 'boolean' },
          { name: 'can_see_all_tickets_from_associated_departments', type: 'boolean' },
          { name: 'has_logged_in', type: 'boolean' },
          { name: 'active', type: 'boolean', control_type: 'checkbox', sticky: true,
            toggle_hint: 'Select from list',
            toggle_field: {
              name: 'active', label: 'Active',
              type: 'string', control_type: 'text', optional: true,
              toggle_hint: 'Use custom value',
              hint: 'Allowed values are: <b>true</b>, <b>false</b>'
            } },
          { name: 'auto_assign_tickets', type: 'boolean' },
          { name: 'vip_user', label: 'VIP user', type: 'boolean' },
          { name: 'group_ids', label: 'Group IDs', type: 'array', of: 'integer' },
          { name: 'member_of', type: 'array', of: 'integer' },
          { name: 'observer_of', type: 'array', of: 'integer' },
          { name: 'external_id' },
          { name: 'custom_fields' },
          { name: 'scopes', type: 'object', properties: [
            { name: 'ticket' },
            { name: 'problem' },
            { name: 'change' },
            { name: 'release' },
            { name: 'asset' },
            { name: 'solution' },
            { name: 'contract' }
          ] },
          { name: 'auto_assign_status_changed_at', type: 'date_time' },
          { name: 'last_active_at', type: 'date_time' },
          { name: 'last_login_at', type: 'date_time' },
          { name: 'created_at', type: 'date_time' },
          { name: 'updated_at', type: 'date_time' }
        ]
        dynamic_schema = (get('agent_fields')['agent_fields']).
                         reject { |field| (field['default_field'].to_s == 'true') }

        call('build_schema_from_metadata',
             'dynamic_schema' => dynamic_schema,
             'static_schema' => static_schema,
             'operation' => 'read')
      end
    }
  },

  actions: {
    custom_action: {
      subtitle: 'Build your own Freshservice action with a HTTP request',

      help: {
        body: 'Build your own Freshservice action with a HTTP request. ' \
        'The request will be authorized with your Freshservice connection.',
        learn_more_url: 'https://api.freshservice.com/v2',
        learn_more_text: 'Freshservice API documentation'
      },

      description: lambda do |object_value, _object_label|
        '<span class="provider"> '\
        "#{object_value[:action_name] || 'Custom action'}</span> in " \
        '<span class="provider">Freshservice</span>'
      end,

      config_fields: [
        {
          name: 'action_name',
          hint: "Give this action you're building a descriptive name, e.g. \
            create record, get record",
          default: 'Custom action',
          optional: false,
          schema_neutral: true
        },
        {
          name: 'verb',
          label: 'Method',
          hint: 'Select HTTP method of the request',
          optional: false,
          control_type: 'select',
          pick_list: %w[get post put patch options delete]
            .map { |verb| [verb.upcase, verb] }
        }
      ],

      input_fields: lambda do |object_definition|
        object_definition['custom_action_input']
      end,

      execute: lambda do |_connection, input|
        verb = input['verb']
        error("#{verb.upcase} not supported") if %w[get post put patch options delete].exclude?(verb)
        path = input['path']
        data = input.dig('input', 'data') || {}
        if input['request_type'] == 'multipart'
          data = data.each_with_object({}) do |(key, val), hash|
            hash[key] = if val.is_a?(Hash)
                          [val[:file_content],
                           val[:content_type],
                           val[:original_filename]]
                        else
                          val
                        end
          end
        end
        request_headers = input['request_headers']
          &.each_with_object({}) do |item, hash|
          hash[item['key']] = item['value']
        end || {}
        request = case verb
                  when 'get'
                    get(path, data)
                  when 'post'
                    if input['request_type'] == 'raw'
                      post(path).request_body(data)
                    else
                      post(path, data)
                    end
                  when 'put'
                    if input['request_type'] == 'raw'
                      put(path).request_body(data)
                    else
                      put(path, data)
                    end
                  when 'patch'
                    if input['request_type'] == 'raw'
                      patch(path).request_body(data)
                    else
                      patch(path, data)
                    end
                  when 'options'
                    options(path, data)
                  when 'delete'
                    delete(path, data)
                  end.headers(request_headers)
        request = case input['request_type']
                  when 'url_encoded_form'
                    request.request_format_www_form_urlencoded
                  when 'multipart'
                    request.request_format_multipart_form
                  else
                    request
                  end
        response =
          if input['response_type'] == 'raw'
            request.response_format_raw
          else
            request
          end
          .after_error_response(/.*/) do |code, body, headers, message|
            error({ code: code, message: message, body: body, headers: headers }
              .to_json)
          end

        response.after_response do |_code, res_body, res_headers|
          {
            body: res_body ? call('format_response', res_body) : nil,
            headers: res_headers
          }
        end
      end,

      output_fields: lambda do |object_definition|
        object_definition['custom_action_output']
      end
    },

    get_agent_by_id: {
      description: "Get <span class='provider'>Agent details by ID</span> " \
      "in <span class='provider'>Freshservice</span>",

      execute: lambda do |_connection, input|
        get("agents/#{input['id']}").
          after_error_response(/.*/) do |_code, body, _header, message|
            error("#{message}: #{body}")
          end['agent']
      end,

      input_fields: lambda do |_object_definitions|
        [{ name: 'id', label: 'Agent ID', optional: false,
           control_type: 'integer', type: 'integer' }]
      end,

      output_fields: lambda do |object_definitions|
        object_definitions['agent_read']
      end,

      sample_output: lambda do |_connection, _input|
        get('agents', per_page: 1).dig('agents', 0)
      end
    },

    search_agents: {
      description: "Search <span class='provider'>Agents</span> " \
      "in <span class='provider'>Freshservice</span>",
      help: 'The Search action will return results that match all your ' \
        'search criteria. Returns a maximum of 30 records.',

      input_fields: lambda do |object_definitions|
        object_definitions['agent_read'].
          only('email', 'mobile_phone_number', 'work_phone_number', 'active').
          concat(
            [
              { name: 'state', control_type: 'select', pick_list: 'agent_state',
                toggle_hint: 'Select from list', sticky: true,
                toggle_field: {
                  name: 'state', label: 'State', optional: true,
                  type: 'string', control_type: 'text',
                  toggle_hint: 'Use custom value',
                  hint: 'Allowed values are: <b>fulltime</b> or <b>occasional</b>'
                } }
            ]
          )
      end,

      execute: lambda do |_connection, input|
        get('agents?per_page=30', input).
          after_error_response(/.*/) do |_code, body, _header, message|
            error("#{message}: #{body}")
          end
      end,

      output_fields: lambda do |object_definitions|
        [{ name: 'agents', type: 'array', of: 'object',
           properties: object_definitions['agent_read'] }]
      end,

      sample_output: lambda do |_connection, _input|
        get('agents', per_page: 1)
      end
    },

    create_requester: {
      description: "Create <span class='provider'>requester</span> " \
      "in <span class='provider'>Freshservice</span>",

      input_fields: lambda do |object_definitions|
        object_definitions['requester_create'].ignored('id')
      end,

      execute: lambda do |_connection, input|
        field_present = false
        %w[primary_email work_phone_number mobile_phone_number].each do |field|
          field_present ||= input[field].present?
        end
        unless field_present
          error('Anyone of the three attributes (primary_email, ' \
          'work_phone_number or mobile_phone_number) is mandatory.')
        end

        post('requesters', input)
          .after_error_response(/.*/) do |_code, body, _header, message|
          error("#{message}: #{body}")
        end['requester']
      end,

      output_fields: lambda do |object_definitions|
        object_definitions['requester_read']
      end,

      sample_output: lambda do |_connection, _input|
        get('requesters', per_page: 1).dig('requesters', 0) || {}
      end
    },

    update_requester: {
      description: "Update <span class='provider'>requester</span> " \
      "in <span class='provider'>Freshservice</span>",

      execute: lambda do |_connection, input|
        put("requesters/#{input.delete('id')}", input)
          .after_error_response(/.*/) do |_code, body, _header, message|
          error("#{message}: #{body}")
        end['requester']
      end,

      input_fields: lambda do |object_definitions|
        object_definitions['requester_update']
      end,

      output_fields: lambda do |object_definitions|
        object_definitions['requester_read']
      end,

      sample_output: lambda do |_connection, _input|
        get('requesters', per_page: 1).dig('requesters', 0) || {}
      end
    },

    get_requester_by_id: {
      description: "Get <span class='provider'>requester by ID</span> " \
      "in <span class='provider'>Freshservice</span>",

      execute: lambda do |_connection, input|
        get("requesters/#{input['id']}")
          .after_error_response(/.*/) do |_code, body, _header, message|
          error("#{message}: #{body}")
        end['requester']
      end,

      input_fields: lambda do |object_definitions|
        object_definitions['requester_read'].only('id').required('id')
      end,

      output_fields: lambda do |object_definitions|
        object_definitions['requester_read']
      end,

      sample_output: lambda do |_connection, _input|
        get('requesters', per_page: 1).dig('requesters', 0) || {}
      end
    },

    search_requesters: {
      description: "Search <span class='provider'>requesters</span> " \
      "in <span class='provider'>Freshservice</span>",
      help: 'Search will return results that match all your ' \
        'search criteria. Returns a maximum of 30 records.',

      input_fields: lambda do |_object_definitions|
        [{
          name: 'email',
          label: 'Email',
          control_type: 'email',
          sticky: true,
          type: 'string',
          hint: 'Email address associated with the requester (can be primary or secondary)'
        },
         {
           name: 'work_phone_number',
           hint: 'Work phone number of the requester.',
           control_type: 'number',
           type: 'integer'
         },
         {
           name: 'mobile_phone_number',
           hint: 'Mobile phone number of the requester.',
           control_type: 'number',
           type: 'integer'
         }]
      end,

      execute: lambda do |_connection, input|
        get('requesters?per_page=30', input)
          .after_error_response(/.*/) do |_code, body, _header, message|
          error("#{message}: #{body}")
        end
      end,

      output_fields: lambda do |object_definitions|
        [{
          name: 'requesters',
          type: 'array',
          of: 'object',
          properties: object_definitions['requester_read']
        }]
      end,

      sample_output: lambda do |_connection, _input|
        get('requesters', per_page: 1)
      end
    },

    create_service_request: {
      description: "Create <span class='provider'>service request</span> " \
      "in <span class='provider'>Freshservice</span>",

      config_fields: [
        {
          name: 'display_id',
          label: 'Service item',
          optional: false,
          control_type: 'select',
          pick_list: 'service_items',
          render_input: 'integer_conversion',
          parse_output: 'integer_conversion',
          type: 'integer',
          toggle_hint: 'Select from list',
          toggle_field: {
            name: 'display_id',
            label: 'Service item',
            toggle_hint: 'Use custom value',
            hint: 'Item display id',
            control_type: 'number',
            render_input: 'integer_conversion',
            parse_output: 'integer_conversion',
            type: 'integer'
          }
        }
      ],

      input_fields: lambda do |object_definitions|
        object_definitions['service_request_create']
      end,

      execute: lambda do |_connection, input|
        id = get("/catalog/items/#{input['display_id']}.json").dig('catalog_item', 'id')
        data = {
          'requested_item_values' => {
            input['display_id'] => {
              'item_id' => id,
              'quantity' => input['quantity'],
              'requested_item_value_attributes' => input['requested_item_value_attributes']
            }
          },
          'requested_for' => input['requested_for'],
          'requester_email' => input['requester_email']
        }

        post("/catalog/request_items/#{input['display_id']}/service_request.json",
             data).after_error_response(/.*/) do |_code, body, _header, message|
          error("#{message}: #{body}")
        end['service_request']
      end,

      output_fields: lambda do |object_definitions|
        object_definitions['service_request_read']
      end,

      sample_output: lambda do |_connection, _input|
        {
          'id' => 19_000_011_289,
          'requester_id' => 19_000_016_643,
          'responder_id' => nil,
          'status' => 2,
          'source' => 2,
          'spam' => false,
          'deleted' => false,
          'created_at' => '2021-06-12T20:25:01-04:00',
          'updated_at' => '2021-06-12T20:25:01-04:00',
          'subject' => 'Request for  => Adobe indesign',
          'display_id' => 19,
          'owner_id' => nil,
          'group_id' => nil,
          'due_by' => '2021-06-16T14:00:00-04:00',
          'frDueBy' => '2021-06-14T16:00:00-04:00',
          'isescalated' => false,
          'priority' => 2,
          'fr_escalated' => false,
          'to_email' => nil,
          'email_config_id' => nil,
          'ticket_type' => 'Service Request',
          'urgency' => 1,
          'impact' => 1,
          'department_id_value' => nil,
          'category' => nil,
          'sub_category' => nil,
          'item_category' => nil,
          'requested_catalog_items' => [
            {
              'id' => 19_000_004_340,
              'service_request_id' => 19_000_011_289,
              'item_id' => 19_000_067_525,
              'is_parent' => true,
              'stage' => 1,
              'quantity' => 1,
              'created_at' => '2021-06-12T20:25:02-04:00',
              'updated_at' => '2021-06-12T20:25:02-04:00',
              'remarks' => nil,
              'from_date' => nil,
              'to_date' => nil,
              'location_id' => nil,
              'item_type' => 1,
              'custom_field_values' => {}
            }
          ]
        }
      end
    },

    create_incident: {
      description: "Create <span class='provider'>incident</span> " \
      "in <span class='provider'>Freshservice</span>",
      help: "Only tickets of type 'Incident' can be created using this action!",

      input_fields: lambda do |object_definitions|
        object_definitions['ticket_create']
      end,

      execute: lambda do |_connection, input|
        requester = input['requester']
        requester_payload = {
          requester_id: requester['requester_id'],
          email: requester['email'],
          phone: requester['phone'],
          name: requester['name']
        }.compact

        field_present = false
        %w[requester_id email phone].each do |field|
          field_present ||= input['requester'][field].present?
        end
        unless field_present
          error('Anyone of the five attributes (requester_id, email, phone, ' \
          'status, priority, source) is mandatory.')
        end
        post('tickets', input.except('requester')&.merge(requester_payload))
          .after_error_response(/.*/) do |_code, body, _header, message|
          error("#{message}: #{body}")
        end['ticket']
      end,

      output_fields: lambda do |object_definitions|
        object_definitions['ticket_read']
      end,

      sample_output: lambda do |_connection, _input|
                       get('tickets', per_page: 1).dig('tickets', 0) || {}
                     end
    },

    search_tickets: {
      description: "Search <span class='provider'>tickets</span> " \
      "in <span class='provider'>Freshservice</span>",
      help: 'Search will return results that match all your ' \
        'search criteria. Returns a maximum of 30 records.',

      input_fields: lambda do |_object_definitions|
        [
          {
            name: 'email',
            label: 'Requester',
            control_type: 'email',
            sticky: true,
            optional: true,
            type: 'string',
            toggle_hint: 'Requester email',
            toggle_field: {
              name: 'requester_id',
              label: 'Requester',
              toggle_hint: 'Requester ID',
              control_type: 'number',
              sticky: true,
              optional: true,
              render_input: 'integer_conversion',
              parse_output: 'integer_conversion',
              type: 'integer'
            }
          },
          {
            name: 'filter',
            label: 'Predefined filters',
            sticky: true,
            optional: true,
            control_type: 'select',
            pick_list: [%w[New\ and\ my\ open new_and_my_open],
                        %w[Watching watching], %w[Spam spam],
                        %w[Deleted deleted]],
            toggle_hint: 'Select from option list',
            toggle_field: {
              name: 'filter',
              label: 'Predefined filters',
              sticky: true,
              optional: true,
              hint: 'Allowed values are: <b>new_and_my_open</b>, <b>watching</b>, ' \
                          '<b>spam</b>, and <b>deleted</b>.',
              toggle_hint: 'Use custom value',
              control_type: 'text',
              type: 'string'
            }
          },
          {
            name: 'order_by',
            label: 'Sort by',
            sticky: true,
            optional: true,
            control_type: 'select',
            pick_list: 'search_order_by',
            toggle_hint: 'Select from option list',
            toggle_field: {
              name: 'order_by',
              label: 'Sort by',
              sticky: true,
              optional: true,
              hint: 'Allowed values are: <b>due_by</b>, <b>created_at</b>, ' \
              '<b>updated_at</b>, <b>priority</b>, and <b>status</b>',
              toggle_hint: 'Use custom value',
              control_type: 'text',
              type: 'string'
            }
          }
        ]
      end,

      execute: lambda do |_connection, input|
        get('tickets?per_page=30', input)
         .after_error_response(/.*/) do |_code, body, _header, message|
          error("#{message}: #{body}")
        end
      end,

      output_fields: lambda do |object_definitions|
        [{
          name: 'tickets',
          type: 'array',
          of: 'object',
          properties: object_definitions['ticket_read']
        }]
      end,

      sample_output: lambda do |_connection, _input|
        get('tickets', per_page: 1)
      end
    }
  },

  triggers: {
    new_ticket: {
      description: "New <span class='provider'>ticket</span> " \
      "in <span class='provider'>Freshservice</span>",

      input_fields: lambda do |_object_definitions|
        [{
          name: 'since',
          label: 'When first started, this recipe should pick up events from',
          hint: 'When you start recipe for the first time, it picks up ' \
          'trigger events from this specified date and time. Leave ' \
          'empty to get events created one hour ago',
          sticky: true,
          optional: true,
          type: 'timestamp'
        }]
      end,

      poll: lambda do |_connection, input, closure|
        closure ||= {}
        page_size = 100
        page = closure['page'] || 1
        updated_since = closure['since'] || (input['since'] || 1.hour.ago)
                        .to_time.utc.iso8601
        params = {
          per_page: page_size,
          page: page,
          updated_since: updated_since,
          order_type: 'asc'
        }.compact
        tickets = get('tickets', params)['tickets']
        if (more_pages = tickets.size >= page_size)
          closure['since'] = updated_since
          closure['page'] = page + 1
        else
          closure['since'] = tickets.dig(-1, 'updated_at')
          closure['page'] = 1
        end

        { events: tickets, next_poll: closure, can_poll_more: more_pages }
      end,

      dedup: ->(ticket) { ticket['id'] },

      output_fields: lambda do |object_definitions|
        object_definitions['ticket_read']
      end,

      sample_output: lambda do |_connection, _input|
        get('tickets', per_page: 1).dig('tickets', 0) || {}
      end
    },

    new_updated_ticket: {
      title: 'New/updated ticket',
      description: "New or updated <span class='provider'>ticket</span> " \
        "in <span class='provider'>Freshservice</span>",

      input_fields: lambda do |_object_definitions|
                      [{
                        name: 'since',
                        label: 'When first started, this recipe should pick up events from',
                        hint: 'When you start recipe for the first time, it picks up ' \
                        'trigger events from this specified date and time. Leave ' \
                        'empty to get events created one hour ago',
                        sticky: true,
                        optional: true,
                        type: 'timestamp'
                      }]
                    end,

      poll: lambda do |_connection, input, closure|
              closure ||= {}
              page_size = 100
              page = closure['page'] || 1
              updated_since = closure['since'] || (input['since'] || 1.hour.ago)
                              .to_time.utc.iso8601
              params = {
                per_page: page_size,
                page: page,
                updated_since: updated_since,
                order_type: 'asc'
              }.compact
              tickets = get('tickets', params)['tickets']
              if (more_pages = tickets.size >= page_size)
                closure['since'] = updated_since
                closure['page'] = page + 1
              else
                closure['since'] = tickets.dig(-1, 'updated_at')
                closure['page'] = 1
              end

              { events: tickets, next_poll: closure, can_poll_more: more_pages }
            end,

      dedup: ->(ticket) { "#{ticket['id']}@#{ticket['updated_at']}" },

      output_fields: lambda do |object_definitions|
        object_definitions['ticket_read']
      end,

      sample_output: lambda do |_connection, _input|
        get('tickets', per_page: 1).dig('tickets', 0) || {}
      end
    }
  },

  pick_lists: {

    ticket_categories: lambda do |_connection|
      fields = get('ticket_fields')['ticket_fields']
      categories = fields.map { |item| item['choices'] if item['name'] == 'category' }.compact
      categories[0].map { |key, _value| [key.labelize, key] }
    end,

    ticket_sub_categories: lambda do |_connection, category:|
      fields = get('ticket_fields')['ticket_fields']
      categories = fields.map { |item| item['choices'] if item['name'] == 'category' }.compact
      categories[0][category].map { |key, _value| [key.labelize, key] }
    end,

    ticket_item_categories: lambda do |_connection, category:, sub_category:|
      fields = get('ticket_fields')['ticket_fields']
      categories = fields.map { |item| item['choices'] if item['name'] == 'category' }.compact
      categories[0][category][sub_category].map { |item| [item.labelize, item] }
    end,

    priorities: lambda do |_connection|
      [['Low', 1], ['Medium', 2], ['High', 3], ['Urgent', 4]]
    end,

    urgencies: lambda do |_connection|
      [
        %w[Low 1],
        %w[Medium 2],
        %w[High 3]
      ]
    end,

    impacts: lambda do |_connection|
      [
        %w[Low 1],
        %w[Medium 2],
        %w[High 3]
      ]
    end,

    search_order_by: lambda do |_connection|
      %w[due_by created_at updated_at priority status].map { |order| [order.labelize, order] }
    end,

    service_items: lambda do |_connection|
                     get('/catalog/items.json').pluck('name', 'display_id')
                   end,

    sources: lambda do |_connection|
               [['Email', 1], ['Portal', 2], ['Phone', 3], ['Chat', 4],
                ['Feedback widget', 5], ['Yammer', 6], ['AWS Cloudwatch', 3],
                ['Pagerduty', 8], ['Walkup', 9], ['Slack', 10]]
             end,

    statuses: lambda do |_connection|
                [['Open', 2], ['Pending', 3], ['Resolved', 4], ['Closed', 5]]
              end,

    ticket_types: ->(_connection) { [%w[Incident Incident]] },

    user_state: lambda do |_connection|
                  [%w[Verified verified], %w[Unverified unverified],
                   %w[All all], %w[Deleted deleted]]
                end,
    agent_state: lambda do |_connection|
      %w[fulltime occasional].map { |state| [state.labelize, state] }
    end
  }
}
